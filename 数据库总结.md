# 数据库总结

## 数据库事务特性
* 原子性
* 一致性
* 隔离性
* 持久性

## 数据库隔离级别
* 读未提交
* 读已提交
* 可重复读
* 串行化
## 数据库隔离级别对应问题
* 读未提交会出现脏读、不可重复读、幻读
* 读已提交会出现不可重复读、幻读
* 可重复读会出现幻读
* 串行化不会出现
* 读已提交会出现不可重复读，侧重修改，可重复读会出现幻读，侧重新增

## 数据库锁

### 锁的分类
* 基于锁的属性分类：共享锁、排它锁
* 基于锁的粒度分类：表锁、行锁（记录锁、间隙锁、临键锁）
* 基于锁的状态分类：意向共享锁、意向排它锁
* 死锁

### 锁的模式
* 读意向锁
* 写意向锁
* 读锁
* 写锁
* 自增锁

### 共享锁
* 共享锁通过lock in share mode实现

### 排它锁
* 排它锁通过for update实现

### 表锁与行锁
* lock table user read(write) 锁表或锁行
* unlock tables 解锁表或者解锁行

### 记录锁
* 记录锁基于主键列或者唯一索引列表，需要精确匹配
### 间隙锁
* 间隙锁锁住的是区间，不包含开始和结束位置的行
* 间隙锁基于非唯一索引
* 间隙锁是左开右开区间数据
### 临键锁
* 临键锁是一种特殊的间隙锁
* 临键锁是左开右闭区间数据
* 临键锁可以解决幻读问题
* 在根据非唯一索引对记录行进行UPDATE\FOR UPDATE\LOCK IN SHARE MODE操作时，InnoDB会获取该记录行的临键锁，并同时获取该记录行下一个区间的间隙锁。

### 死锁的出现
* 两个或者两个以上事务
* 每个事务都已经持有锁并且申请新的锁
* 锁资源同时只能被同一个事务持有或者不兼容
* 事务之间因为持有锁和申请锁导致彼此循环等待

### 死锁的预防
* innodb_lock_wait_timeout 等待锁超时回滚事务
* wait-for graph死锁检测算法

### 死锁的解决
* 等待事务超时，主动回滚。
* 进行死锁检查，主动回滚某条事务，让别的事务能继续走下去

## MVCC多版本并发控制

### 当前读
* select lock in share mode
* select for update
* update
* delete
* insert

### 快照读
* 不加锁的select（隔离级别不是串行化，串行化情况下，快照读退化成当前读）

### MVCC的原理
* 事务ID,db_trx_id
* 回滚指针，db_roll_ptr
* 隐含的自增ID，db_row_id
* read view读视图，rc隔离级别下，每次查询都会生成一个读视图，rr隔离级别下，在事务开启的时候生成一次读视图

### 可见性算法结构
* m_low_limit_id最大事务id
* m_up_limit_id最小事务id
* m_ids活跃事务列表

### 可见性算法过程
* 1、如果db_trx_id < m_up_limit_id，那么表明最新修改该行的事务db_trx_id在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的
* 2、如果db_trx_id >= m_low_limit_id，那么表明最新修改该行的事务db_trx_id在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见,跳到步骤5
* 3、m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的
* 4、如果m_up_limit_id <= DB_TRX_ID < m_low_limit_id，表明最新修改该行的事务db_trx_id在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表m_ids 进行查找（源码中是用的二分查找，因为是有序的）
* 4.1、如果在活跃事务列表m_ids中能找到db_trx_id，表明在当前事务创建快照前，该记录行的值被事务db_trx_id的事务修改了，但没有提交；或者在当前事务创建快照后，该记录行的值被事务db_trx_id的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤5
* 4.2、在活跃事务列表中找不到，则表明db_trx_id的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见
* 5、在该记录行的db_roll_ptr指针所指向的undo log取出快照记录，用快照记录的db_trx_id跳到步骤1重新开始判断，直到找到满足的快照版本或返回空

## 索引

### 索引结构
* myisam索引文件和数据文件是分离的
* innodb索引文件和数据文件不是分离的

### 索引优化
* 全列匹配，可以用到索引
* 最左前缀匹配，可以用到索引
* 精确匹配，但是中间某个条件未提供，如果值不多，可以补全，可以用到索引  
* 通配符 like ‘%字段’可以用到索引
* 范围列可以用到索引,但是范围列后面的列无法用到索引，范围列后面的索引区分多值匹配(可以用到索引)和范围匹配(不可以用到索引)
* 查询条件中含有函数或表达式，不能用到索引
* 前缀索引，例如<first_name, left(last_name, 3)>

### 索引建立建议
* 表记录较少的时候，不需要索引
* 选择性较低的时候，不需要索引

